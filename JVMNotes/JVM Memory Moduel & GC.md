
<!-- toc orderedList:0 -->

- [内存模型](#内存模型)
	- [程序计数器](#程序计数器)
	- [虚拟机栈](#虚拟机栈)
	- [本地方法栈](#本地方法栈)
	- [堆](#堆)
- [垃圾回收机制](#垃圾回收机制)

<!-- tocstop -->

> 关于 JVM 内存模型和垃圾回收机制

![内容结构](<./Imgs/Memory Manage & GC.png>)

# 内存模型

虚拟机的内存模型可以分成线程独享和线程共享两种不同的类型。其中，线程独享的包括程序计数器、虚拟机栈和本地方法栈；这些专享的内存空间对于应用程序的每一个线程来说都是独有的，用于保存当前线程执行的关键上下文内容。而线程共享内容则有堆区和方法区两个部分；堆区是存贮应用程序创建出来的对象的场所，同时也是垃圾回收操作发生的主要区域；方法区保存应用程序通过虚拟机加载进来的类信息、常量以及静态变量等内容；方法区和堆区两个在虚拟机中都是被所有线程锁共享的存储空间。下面分别对对提及到的内存区域进行详细的介绍。

## 程序计数器

程序计数器是一小块内存空间，在里面保存了当前线程执行代码的行号。在应用程序执行的时候，字节码解析器通过改变程序计数器中保存的值来决定下一步代码的执行位置，程序运行分支、循环、异步处理、线程恢复等功能都需要依赖于程序计数器。因为在 Java 程序中多线程模型是通过时间片为不同的线程分配处理器时间来完成的，所以不同的线程为了保证线程恢复的正确性，不同的线程之间会拥有各自不同的程序计数器来保存执行代码行号。

如果线程当前执行的是一段 Java 代码，那么在程序计数器中保存的就是这段代码的行号；如果当前执行的本地方法，程序计数器中保存一个空值。在此内存空间中没有定义任何的 OOM 的情况。

## 虚拟机栈

虚拟机栈是 Java方法 执行的内存模型。当在线程中执行一个新的方法时，会创建一个对应的栈帧压入到虚拟机栈中，在这个栈帧中保存有当前函数执行的局部变量表、操作数栈、动态链接、方法出口等内容；当该方法执行完成之后该栈帧会从虚拟机栈中弹出。

局部变量表保存当前方法中的局部变量信息，这些信息包括在编译时期就可以确定的基本数据变量、引用类型变量和 returnAddress类型。这些数据保存在局部变量表中除了`double/long`类型会占用两个`slot`局部变量表空间之外，其余都只占用一个`slot`，所以一个方法栈帧需要为其局部变量表分配多少的存储空间其实在编译的时候就已经知道了。

虚拟机栈发生错误的情况有两种不同的类型。如果当前虚拟机栈是不可动态扩容的，在没有足够的空间满足新的方法栈帧请求的时候，会出现`StackOverflowError`的异常；在虚拟机栈可以动态扩容但是同样没有足够的空间满足当前方法栈帧请求的情况下，则会出现`OutOfMemoryError`异常。

## 本地方法栈

本地方法栈和虚拟机栈类似同样是用于描述方法执行的内存模型，不过描述的对象是运行的本地方法。

## 堆

堆是虚拟机管理的最大一片内存区域，伴随着虚拟机的启动而创建。其存在的唯一目的是保存几乎所有的对象实例和数组。同时因为对象生命周期的问题，伴随着应用程序的运行，势必会出现无用的对象，而为了保证堆上内存可以得到充分的利用，堆也必然成为了垃圾回收的主要场所。在为新创建的对象申请堆上内存的时候，如果堆上没有足够的内容进行分配，则会出现`OutOfMemoryError`的异常。

## 方法区

Java 程序经过编译之后类相关的信息保存在 Class 文件中，在应用程序运行过程中需要使用到某个类而通过 Class 文件去加载这个类的信息的时候，就需要用到方法区来保存这些类信息以及产生的静态变量和常量。

# 垃圾回收机制

Java 提供自动的内存管理机制，其中自然包括内存的垃圾回收。
