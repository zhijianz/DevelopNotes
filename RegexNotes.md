# 正则表达式

## 参考资料
[正则表达式入门参考](http://deerchao.net/tutorials/regex/regex.htm)
[零宽断言](http://hooopo.iteye.com/blog/407062)

## 分组
&emsp;分组是正则表达式中的一个子表达式，通常用`()`标识出来。在不同编程语言实现的正则表达式功能中，通常会提供对分组表达式匹配结果的定位获取和重用等操作，并且分组本身捕获的内容在正则表达式中也可以重复利用。可以参考后面的`Python`描述。

    \d(\w)\d    #(\w)是一个分组

## 后向引用
&emsp;在提及`分组`的时候说过分组捕获的内容会被复用。因为在表达式中，每遇到一个分组其实的左括号的时候会自动为这个分组分配一个`ID标识`。在表达式后续的内容中，可以通过这个`ID标识`对这个分组捕获的文本内容进行引用，这样的实现方式称作分组的`后向引用`。实现`后向引用`的方式除了使用表达式自动为分组分配的`ID标识`之外，也可以为分组提供自定义的`别名`并通过这个`别名`实现分组的`后向引用`
```python
#下面是一个通过ID进行后向引用的例子
#(\w+)是ID:1的分组，通过\1对这个分组捕获的文本内容进行后向引用
#这个正则表达式最终实现的效果是匹配重覆叠词,如：go go
\b(\w+)\b\s+\1\b

#下面的表达式是上述的别名引用实现
#(?<Word>\w+)通过语法?<name>为分组定义别名
#\k<Word>通过语法\k<name>对别名分组进行引用
\b(?<Word>\w+)\b\s+\k<Word>\b
```

## 零宽断言

&emsp;`零宽`指的是消费的宽度为0。`断言`表述的是一种应该为真的假设，在正则表达式中只有断言为真的时候才会进行匹配。在介绍`零宽断言`之前需要明确另外一个概念就是`消费`,在表达式匹配的过程中，每次根据表达式定义的规则从测试内容中获取一个字符到结果集中定义为`消费一个宽度字符`。到目前为止学到的正则表达式规则都会消费测试内容，`零宽断言`则是一个不会消费测试内容的特例。在`零宽断言`规则中定义的正则表达式在匹配的时候只会用来进行定位，为不会对捕获的内容进行消费放置到结果集中；所以，`零宽断言`的重要作用在于匹配过程的定位功能，除此以外普通的正则表达式规则完全可以代替。

    #下面的表达式"\w+."对于两个测试的文本都会完全匹配，
    #如果期望"."只是起到一个定位的作用而不会出现在匹配结果中
    #则现在的匹配规则明显是错误的
    \w+.
    regular.
    expression.

    #下面的表达式用先行零度断言实现上述要求
    #这里(?=.)表示匹配位置后面必须满足这样的要求
    #但是这个断言捕获的文字不会放置到结果集中
    \w+(?=.)

    #零宽度正预测先行断言
    #(?=exp)
    #下面的表达式使用正向先行断言匹配ing结尾的字符串
    exp:\w+(?=ing\b)
    test:coding
    result:cod
    #需要注意的是，先行断言匹配的方式是先从字符串的右边开始寻找
    #满足断言的位置然后匹配，所以对于下面的表达式会出现下面的结果
    exp:.*(?=ing\b)
    test:coding reading
    result:coding read

    #零宽度正回归后发断言
    #(?<=exp)
    #下面的表达式使用正向后发断言匹配abc开头的单词
    exp:(?<=\badb)\w+
    test:dcd adbd
    result:d
    #同样需要注意的是，后发断言会从字符串的左边开始匹配断言
    #在第一个满足断言的地方匹配正则表达式，所以下面的表达式会出现下面的结果
    exp:(?<=\babd).*
    test:abddc ad
    reuslt:dc ab

    #上面介绍的都是正向零宽断言，用来规定指定位置满足的条件
    #下面介绍负向零宽断言，用来规定指定位置不能够满足的条件

    #零宽度负预测先行断言
    #(?!exp)
    #下面的表达式用来匹配不以ing结尾的字符串
    exp:.*(?!ing|\b)
    test:coding reading
    result:coding readin

    #零宽度负回归后发断言
    #(?<!exp)
    #下面的表达式用来匹配不以abc开头的字符串
    exp:(?<!\babc).*
    test:abcdef ddccd
    reuslt:ddccd

## 贪婪和懒惰模式

&emsp;在正则表达式中，如果包含了重复限定词，在匹配的时候会尽可能多的去匹配测试文本内容，这个是正则表达式默认情况下的贪婪模式

    #在下面的例子中，表达式期望匹配的结果是a开始b结尾的字符串
    #可以看到在测试文本内容中有很多满足这个内容的子字符串
    #但是最终匹配的结果是整个测试文本内容，这个就是正则表达式的贪婪模式
    exp:a.*b
    test:aabaaabbab
    result:aabaaabbab

&emsp;有的情况下，贪婪的匹配模式可能和我们的预期刚好相反，这个时候可以使用正则表达式提供的懒惰模式，在重复限定词后面加上？即可

    #和上面使用的是同样的例子，区别在于启用了懒惰的匹配模式
    #这个时候匹配出来的文本内容是aab而不是整个文本内容
    exp:a.*?b
    test:aabaaabbab
    result:aab
对于上面的例子获取会有另外一个疑惑，匹配的结果为什么不是ab而是aab，明显前者才是匹配的最优答案。这里涉及到正则表达式的另外一条规则：`最先开始的匹配拥有最高优先级`

## 平衡组

&emsp;第一眼惊为天人，第二眼原来只有`.NET`等部分语言支持，第三眼`Python`不支持。正则表达式的平衡组因为支持栈操作，所以将多层嵌套内容的匹配变成了可能。

    #将捕获的内容明明并压入栈中
    exp:(?<name>)

    #从堆栈中推出最后匹配的特定名称的分组捕获内容，如果堆栈本来为空，分组捕获失败
    exp:(?<-name>)

    #如果堆栈上存在特定名称的分组捕获内容则执行yes表达式，否则执行no表达式
    exp:(?(name)yes|no)

    #负零宽断言，因为后面没有跟表达式，所以尝试匹配会返回错误
    exp:(?!)

    #下面的例子尝试匹配由<>嵌套定义的文本内容
    exp:<[^<>]*(((?'open'<)[^<>]*)+((?'-open'>)[^<>]*)+)(?(open)(?!))>

<br/>
<br/>

# Python正则表达式
## 字符串编码格式

&emsp;`Python`的正则表达式的字符串支持`Byte/Unicode`两种编码格式，但是有个要求就是在使用的时候两种格式不能够混合使用。具体的就是要求匹配字符串，匹配规则，替换字符串都统一地使用两种编码格式中的某一种而不能够混合使用。

## 转义处理

&emsp;`Python`正则表达式中，使用反斜杠对需要的字符串进行转义操作，例如`\n`表示新行，但是这样的处理方式可能会导致可能表达的特殊含义和字面含义发生冲突。拿`\n`进行举例，如果在使用正则表达式的时候就是希望表达其字面上两个字符的意思，需要对第一的反斜杠符号进行转义处理，从而变成`\\n`；如果希望在正则表达式中使用`\\`的字面意思，则需要将其表述成为`\\\\`。`Pthon`提供了另外一种解决方案：在需要处理的字符串前加上`r`前缀，解析器会按照字符串的字面意思进行处理而不会进行转义。再次用`\n`举例，字符串`r"\n"`在`Python`的解析器看来，就是一个`\n`的字面含义而不是转义之后的意思。
